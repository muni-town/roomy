/**
 * This file exports JSON Schema and ATProto Lexicon definitions for the Roomy event type.
 *
 * The lexicon is generated from the JSON schema that is generated by Arktype.
 *
 * We could possibly ( and maybe preferably ) generate this from Arktype's internal representation,
 * but that appears to be unstable and it may actually be more difficult to deal with because it is
 * richer than lexicons while JSON-schema is relatively similar.
 *
 * The logic has to hack around some specific cases to work properly. It has been manually checked
 * that it makes appropriate lexicons for the types that we have at the time of writing.
 */

import { type LexiconDoc, type LexObject } from "@atproto/lexicon";
import { Event } from "./envelope";
import type { JsonSchema } from "arktype";

/**
 * Symbol that marks types which cannot be serialized and should be stripped from the JSON schema
 * when converting to a lexicon. */
const ignoreInSchema = Symbol();

// Generate the JSON schema represntation
const eventJsonSchema = Event.toJsonSchema({
  fallback: {
    predicate: (ctx) => ctx.base,
    proto: () => ignoreInSchema,
  },
});

type LexObjProps = LexObject["properties"];
type LexObjProp = LexObjProps[keyof LexObjProps];

/** Start a list of lexicons. */
const eventLexicons: LexiconDoc[] = [];

/**
 * Convert a union variant schema to a lexicon definition and return the NSID.
 *
 * The lexicon def will automatically be added to the lexicons list.
 * */
const schemaVariantToNsid = (schema: JsonSchema.NonBooleanBranch): string => {
  if (
    "properties" in schema &&
    schema.properties &&
    schema.properties["$type"] &&
    "const" in schema.properties["$type"] &&
    typeof schema.properties["$type"].const == "string"
  ) {
    const nsid = schema.properties["$type"].const;

    delete schema.properties["$type"];
    schema.required = schema.required?.filter((x) => x !== "$type") || [];

    eventLexicons.push({
      lexicon: 1,
      id: nsid,
      description: schema.description,
      defs: schemaToLexiconDefs(schema, 0),
    });

    return nsid;
  }

  throw {
    message: "invalid schema for global union variant",
    schema,
  };
};

/**
 * Convert an object property schema to a lexicon object.
 *
 * @param defN The current definition number. If the object schema requires any sub-definitions, a
 * definition starting at this number will be created and returned in `extraDefs`. The defs will be
 * named like `#defN` where `N` is one more than def number for the first def, and incremented by
 * one for each other def needed by this object property.
 */
const schemaToObjProp = (
  schema: JsonSchema.NonBooleanBranch,
  defN: number,
): {
  prop: LexObjProp;
  nullable: boolean;
  extraDefs?: LexObject[];
} => {
  // Handle unions.
  if ("anyOf" in schema) {
    // It is nullable if null is one of the union variants
    const nullable = schema.anyOf.some((x) => "type" in x && x.type == "null");

    // Take the null out of the union list if present. Also remove ignored types.
    const anyOf = schema.anyOf.filter(
      (x) => !("type" in x && x.type == "null") && x != ignoreInSchema,
    );

    // If there is only one type in the union, just return the property for that type, not a union.
    if (anyOf.length == 1) {
      return { ...schemaToObjProp(anyOf[0]!, defN), nullable };
    }

    if (anyOf.every((x) => "const" in x && typeof x.const == "string")) {
      // If this is a union of all strings, then return a string type with a list of known values.
      return {
        prop: {
          type: "string",
          knownValues: anyOf.flatMap((x) => (x as any).const as string),
          description: schema.description,
        },
        nullable,
      };
    } else {
      // If this is any other kind of union
      return {
        prop: {
          type: "union",
          // Create a lexicon and get the NSID for the union variant
          refs: anyOf.map((x) => schemaVariantToNsid(x)),
          description: schema.description,
        },
        nullable,
      };
    }
  } else if ("type" in schema && schema.type == "boolean") {
    // If this is a boolean
    return {
      prop: {
        type: "boolean",
        description: schema.description,
      },
      nullable: false,
    };
  } else if ("type" in schema && schema.type == "string") {
    // If this is a string
    return {
      prop: {
        type: "string",
        description: schema.description,
      },
      nullable: false,
    };
  } else if ("type" in schema && schema.type == "integer") {
    // If this is an integer
    return {
      prop: {
        type: "integer",
        description: schema.description,
      },
      nullable: false,
    };
  } else if (
    "type" in schema &&
    schema.type == "object" &&
    "properties" in schema &&
    schema.properties
  ) {
    // If this is an object with properties

    // If this is an object with a single `$bytes` field, then it should be a bytes type.
    const propNames = Object.keys(schema.properties);
    if (propNames.length == 1 && propNames[0] == "$bytes") {
      return {
        prop: {
          type: "bytes",
          description: schema.description,
        },
        nullable: false,
      };
    }

    // If this is an object, we need to create a new definition for it, because we cannot directly
    // inline an object definition in another object.

    // Get the definition number
    defN += 1;
    const ref = `#def${defN}`;

    // Create the definition(s)
    const extraDefs = schemaToLexiconDefs(schema, defN);

    return {
      // Return a ref to the definition that we created
      prop: {
        type: "ref",
        ref,
        description: schema.description,
      },
      // And return all the defs that created, too.
      extraDefs: Object.values(extraDefs),
      nullable: false,
    };
  } else if (
    "type" in schema &&
    schema.type == "array" &&
    "items" in schema &&
    schema.items &&
    typeof schema.items != "boolean" &&
    !Array.isArray(schema.items)
  ) {
    // If this is an array, calculate the lexicon def for the item type
    const { prop, nullable, extraDefs } = schemaToObjProp(
      schema.items as any,
      defN,
    );
    return {
      prop: {
        type: "array",
        // This is a lame cast to make but it's easier to just cast and double check that it passes
        // ATProto's Zod verification than to make the type accurate.
        //
        // The only difference in the type is something small like arrays not being able to have
        // arrays as an item type.
        items: prop as any,
        description: schema.description,
      },
      nullable,
      extraDefs,
    };
  }

  throw {
    message: "invalid schema for obj prop",
    schema,
  };
};

/**
 * Convert an object property schema to a list of lexicon definitions. This will return a mapping
 * that can be used as the top-level `defs` in a lexicon document. The top-level type in the
 * `schema` will be returned in the `main` key with it's lexicon definition, and any required
 * sub-definitions for the lexicon will be returned with other keys like `#defN` where `N` will
 * start at a number one higher than the `defN` parameter passed into this function.
 */
const schemaToLexiconDefs = (
  schema: JsonSchema.NonBooleanBranch,
  defN: number,
): { main: LexObject } | Record<string, LexObject> => {
  if ("type" in schema && schema.type == "object" && "properties" in schema) {
    // If this is an object definition.

    // Remove the $type field if present since it doesn't need to get listed in the properties
    // definition.
    delete schema.properties?.["$type"];
    schema.required = schema.required?.filter((x) => x != "$type") || [];

    const nullable: string[] = [];
    const extraDefs: LexObject[] = [];
    const obj: LexObject = {
      type: "object",
      description: schema.description,
      properties: Object.fromEntries(
        // Compute the schema for the properties
        Object.entries(schema.properties || {}).map(([key, value]) => {
          const r = schemaToObjProp(value, defN + extraDefs.length);

          // If the field is nullable, add it to the nullable list
          if (r.nullable) nullable.push(key);

          // Record any of the definitions added by the property
          extraDefs.push(...(r.extraDefs || []));

          // Return the property
          return [key, r.prop];
        }),
      ),
      nullable,
      required: schema.required || [],
    };

    // Return the object, with all of it's definitions
    return {
      main: obj,
      ...Object.fromEntries(extraDefs.map((x, i) => [`def${i + 1}`, x])),
    };
  }

  throw {
    message: "invalid schema for obj",
    schema,
  };
};

/** The top level event lexicon doc */
const eventDef: LexiconDoc = {
  lexicon: 1,
  id: "space.roomy.event.v0",
  description: eventJsonSchema.description,
  defs: schemaToLexiconDefs(eventJsonSchema, 0),
};
eventLexicons.unshift(eventDef);

// Return the lexicons and the JSON schema
export { eventLexicons, eventJsonSchema };
